from robot.mech.serial       import Serial
from robot.spatial.frame     import Frame
from robot.spatial.dual      import Dual
from robot.spatial.transform import Transform

def solve_wrist(target : Frame, arm_angles : list, robot : Serial):
  '''
  Get joint angles from a given target (inverse kinematics)

  This function decouples the position and orientation of the robot into two separate problems
  '''
  solutions = []

  for angle_set in arm_angles:
    # Get current end effector pose generated by moving the arm to provided solution set angles
    previous = robot.angles
    robot.angles = angle_set + [0] * 3
    end_effector = robot.pose()

    # Get "difference" between current end effector pose and the target pose
    # TODO: Operate on quaternions here directly instead of going in and out of transforms/frames.
    inverse = end_effector.transform.inverse()
    result = inverse.dual.r * target.transform.dual.r
    wrist = Frame(Transform(Dual(result, 0)))

    # Must be intrinsic ZYZ based on mechanical configuration of spherical wrist
    #   Axis 4 rotates about Z, Axis 5 rotates about Y, Axis 6 rotates about Z
    # There are at least two solutions
    wrist_sets = wrist.euler(method="intrinsic", order="ZYZ")

    for solution in wrist_sets:
      solutions.append(angle_set + solution)

    robot.angles = previous

  return solutions