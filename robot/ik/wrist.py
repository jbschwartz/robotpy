from robot.spatial import euler

def solve_wrist(target : 'Frame', arm_angles : list, robot : 'Serial'):
  '''
  Get joint angles from a given target (inverse kinematics)

  This function decouples the position and orientation of the robot into two separate problems
  '''
  solutions = []

  for angle_set in arm_angles:
    # Get current end effector pose generated by moving the arm to provided solution set angles
    previous = robot.angles
    robot.angles = angle_set + [0] * 3
    end_effector = robot.pose()

    # Get "difference" between current end effector pose and the target pose
    inverse = end_effector.frame_to_world.inverse()
    delta = inverse.rotation() * target.frame_to_world.rotation()

    # Must be intrinsic ZYZ based on mechanical configuration of spherical wrist
    #   Axis 4 rotates about Z, Axis 5 rotates about Y, Axis 6 rotates about Z
    # There are at least two solutions
    wrist_sets = euler.angles(delta, axes=euler.Axes.ZYZ, order=euler.Order.INTRINSIC)

    solutions.extend([angle_set + wrist_set for wrist_set in wrist_sets])

    robot.angles = previous

  return solutions