from robot.spatial import euler

def solve_wrist(target : 'Frame', arm_angles : list, robot : 'Serial'):
  '''
  Get joint angles from a given target (inverse kinematics)

  This function decouples the position and orientation of the robot into two separate problems
  '''
  solutions = []

  for angle_set in arm_angles:
    # Get current end effector pose generated by moving the arm to provided solution set angles
    # We use the equation by forward kinematics: Current Flange Frame * Delta * Tool Frame = Target
    previous = robot.angles
    robot.angles = angle_set + [0] * 3
    current_flange = robot.links[-1].frame.frame_to_world

    # Get "difference" between current end effector pose and the target pose
    # That is: Delta = Current Flange Inverse * Target * Tool Frame Inverse
    delta = current_flange.inverse() * target.frame_to_world

    if robot.tool is not None:
      delta *= robot.tool._tip.inverse()

    # Must be intrinsic ZYZ based on mechanical configuration of spherical wrist
    #   Axis 4 rotates about Z, Axis 5 rotates about Y, Axis 6 rotates about Z
    # There are at least two solutions
    wrist_sets = euler.angles(delta.rotation(), axes=euler.Axes.ZYZ, order=euler.Order.INTRINSIC)

    solutions.extend([angle_set + wrist_set for wrist_set in wrist_sets])

    robot.angles = previous

  return solutions